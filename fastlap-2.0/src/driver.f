c
c This a driver to test FastLap V1.9 as a callable procedure from fortran.
c The driver illustrates how FastLap may be used for solving potential problems 
c cast as the Green or single layer formulations.  An example field 
c quantity computation is included as well.  
c Input compatible with this driver can be generated by sphere.f if it is 
c processed through c2fdata.  The former code generates the geometry for a 
c sphere and supplies boundary conditions for the sphere translating in an
c infinite fluid.  The Green formulation is set up as a mixed Neumann and 
c Dirichlet problem as dictated by the input file.  The single layer formulation
c is set up by setting the RHS vector to be the potential value supplied in 
c the input file.  The exact solution (including the source strength) is 
c known for this problem, so the error in the solution may be computed and
c is reported by this driver.
c
c Written in Modern Fortran by Korsmeyer, winter 1993.  (c) MIT 1993.
c
      implicit none
      integer size
      parameter (size=8192)
      character*300 line
      double precision x(3,4,size), poten(size), dbydnpoten(size),
     $     xcen(3,size), xcoll(3,size), xnrm(3,size), area(size), 
     $     lhsvect(size), rhsvect(size)
      double precision cos_theta, sin_theta, cos_phi, sin_phi
      double precision DUM1(4,size), DUM2(4,size), DUM3(9,size),
     $     DUM4(4,size), gennorm(6,size)
      integer type(size), shape(size), dtype(size), dummy, job, fljob
      integer rhstype(size), lhstype(size), rhsindex(4,size),
     $     lhsindex(4,size)
      integer NULL, POINT_SOURCE, CONSTANT_SOURCE, CONSTANT_DIPOLE, 
     $     LINEAR_SOURCE, LINEAR_DIPOLE
      data NULL, POINT_SOURCE, CONSTANT_SOURCE, CONSTANT_DIPOLE, 
     $     LINEAR_SOURCE, LINEAR_DIPOLE /0, 1, 11, 12, 21, 22/
      character*80 title, filename
      double precision exact_sol(size)
      integer nummom, numlev, i, j, k, nlhs, nrhs, nsing
      integer call_count
      double precision error, max_diri, ave_diri, max_neum, ave_neum, 
     $     max_error, ave_error, cnt_diri, cnt_neum, cnt_error, max_area
      data max_diri, ave_diri, max_neum, ave_neum, cnt_diri, cnt_neum,
     $     max_error, ave_error, cnt_error, max_area
     $     /10*0.0/
      integer fastlap
      external fastlap
      double precision tolpar, tol
      parameter (tolpar = 0.0001)
      integer numitr, maxitr
      data maxitr /32/
      tol = tolpar
      call_count = 0
c
c Query for run parameters and data file name.
c
c These are the things you can do with the driver:
c job = 0 == compute a field
c job = 1 == solve a Green formulation with mixed conditions.
c job = 2 == solve a single layer formulation.
c
c These are the distinctions fastlap makes:
c fljob = 0 == compute a field (RHS matrix)
c fljob = 1 == solve a problem with L and RHS matrices.
c fljob = 2 == solve a system with the identity as the RHS matrix.
c
      write(*,'(//''You can test the Green formulation, a single ''
     $     ''layer''/''formulation, the source formulation, or a ''
     $     ''field''/''computation.  If you use the input for ''
     $     ''the sphere''/''translating in an infinite fluid, ''
     $     ''there will be''/''error checking as the solution is ''
     $     ''known.  For''/''this case, the input file should be ''
     $     ''one written''/''by sphere.f and processed by ''
     $     ''c2fdata.''/''You may, of course, use your own ''
     $     ''input data.''/)')
      write(*,'(''Testing? ''/
     $     ''                   Field (0)''/
     $     ''                   Green (1)''/ 
     $     ''            Single Layer (2)''/ 
     $     ''      Source Formulation (3)''/ 
     $     ''   Repeated Single Layer (4)   ''$)') 
      read(*,*) job
      write(*,'(''You can run up to '',i4,'' panels.''/)') size
      write(*,'(''Select expansion order and tree depth:  ''$)')
      read(*,*) nummom, numlev
      write(*,'(''Filename for input data?  ''$)')
      read(*,'(a80)') filename
      open(unit=20, file=filename, status='old')
      read(20,'(a80)') title
      write(*,'(''The header in this file is:''/a80)') title
c
c Read in panel data from a file and set the number of singularities (nsing)
c to be the number of panels. 
c
      do i = 1,size
         read(20,'(i1)',end=1) shape(i)
      end do
 1    continue
      nsing = i - 1
      print *, 'Looking for ',nsing,' panels.'
      rewind(20)
      read(20,'(a80)') title
      do i = 1,nsing
         read(20,*) dummy,
     $        ((x(k,j,i),k=1,3),j=1,shape(i)),
     $        poten(i),dbydnpoten(i),type(i)
      end do
c
c Compute the collocation points as the centroids of panels.
c
      call centroid(nsing,x,shape,DUM1,DUM2,xcen,DUM3,
     $     area,DUM4,gennorm)
c
c Here we Scramble the collocation points to test the dis-association of 
C field point and singularity ordering.  All we do is reverse the point 
c listing.  Obviously various schemes can be used to scramble the points, 
c a random int with bubble sort would be nice...  The following was used just
c to see it work at all.  Note that O(N) algorithms differ from O(N^2) on
c this issue.  Try to forget about the O(N^2) ordering of the linear system
c that you are used to where the self influence shows up on the diagonal, 
c here it is immaterial.  Take the 3 cases:
c GREEN:  With both left- and right-hand side matrices, the left- and 
c right-hand side strength indices map the strengths to the singularities and 
c these determine how to decode the solution.  The location (or order)
c for the collocation points doesn't make any difference.  
c INDIRECT:  This case is more restrictive.  Here, the right-hand side
c vector is a condition at a specific collocation point, so the odering
c of the input right-hand side vector must conform to the collocation point 
c ordering, while the output left-hand side vector will conform to the 
c left-hand side strength indices.
c FIELD:  The restriction is similar here.  The input right-hand side 
c vector is mapped to the singularities by the right-hand side strength 
c indices, while the output left-hand side vector will be ordered to 
c conform to the field point locations.
c In the cases below, you can see how the scrambling of the field point 
c locations affects the other input to fastlap.  
c
      j = nsing + 1
      do i = 1, nsing
c
c Reverses order of collocation points wrt panels:
c
c         j = j - 1
c
c Leaves collocation points in same order as panels:
c
         j = i
         xcoll(1,j) = xcen(1,i)
         xcoll(2,j) = xcen(2,i)
         xcoll(3,j) = xcen(3,i)
c
c We set the field point normal as the panel normal, but the 
c routine we called for the normal gave us the normal pointing 
c into the computational domain and we want it to point out, so
c we flip the sign.
c
         xnrm(1,j) = -gennorm(1,i)
         xnrm(2,j) = -gennorm(2,i)
         xnrm(3,j) = -gennorm(3,i)
C
C We initialize the derivative request to zero.
C
         dtype(i) = 0
      end do
c
c Save the exact solution for comparison with computed solution, and
c set the panel left- and right-hand side types and indices to the 
c left- and right-hand side vectors.  N.B. You have to set the signs
c properly for the equation you wish to solve!!
c
c Allowed types are:
c               NULL               0   (not implemented)
c               CONSTANT_SOURCE   11
c               CONSTANT_DIPOLE   12
c               LINEAR_SOURCE     21   (not implemented)
c               LINEAR_DIPOLE     22   (not implemented)
c               POINT_SOURCE       1   
c               POINT_DIPOLE       2   (not implemented)
c	        VORTEX_BLOB        3   (not implemented)
c
c
c This is a continuation point for a repeated single-layer formulation 
c job. (job #4)
c
 4    continue
c
c This is a Green formulation:
c
      if (job .eq. 1) then
         fljob = 1
         nlhs = nsing
         nrhs = nsing
c
c This is the translating sphere N/D problem (like the input).
c
         do i = 1,nsing
            if(type(i) .eq. 0) then
c
c This is a panel on the dirichlet surface:
c
               rhstype(i) = CONSTANT_DIPOLE
               lhstype(i) = CONSTANT_SOURCE
c
c The following values are independent of where we collocate:
c
               exact_sol(i) = dbydnpoten(i)
c
c The vector is set to - the boundary condition to force the 
c sign on the matrix-vector product.  The solution is decoded
c similarly below. 
c
               rhsvect(i) = -poten(i)
               rhsindex(1,i) = i
               lhsindex(1,i) = i
            else if(type(i) .eq. 1) then
c
c This is a panel on the neumann surface:
c
               rhstype(i) = CONSTANT_SOURCE
               lhstype(i) = CONSTANT_DIPOLE
c
c The following values are independent of where we collocate:
c
               exact_sol(i) = poten(i)
               rhsvect(i) = dbydnpoten(i)
               rhsindex(1,i) = i
               lhsindex(1,i) = i
            else  
               write(*,'(''driverf: missing a boundary type.'')')
               stop
            end if
         end do
c
c This is a single layer formulation for the translating sphere.
c
      else if ((job .eq. 2) .or. (job .eq. 4)) then
         fljob = 2
         nlhs = nsing
         nrhs = nsing
c
         do i = 1,nsing
c
c rhstype is meaningless here as this formulation has no RHS matrix, but 
c we need to supply a legal type anyway.
c
            rhstype(i) = CONSTANT_SOURCE
            lhstype(i) = CONSTANT_SOURCE
c
c The solution is known in closed form.  We let xcen(3,i) be cos(theta).
c
            exact_sol(i) = -(3./(8.*3.141459265))*xcen(3,i)
            rhsvect(i) =  -(1./2.) * xcen(3,i)
            rhsindex(1,i) = i
            lhsindex(1,i) = i
         end do
c
c This is a source formulation for the translating sphere.
c
      else if (job .eq. 3) then
         fljob = 2
         nlhs = nsing
         nrhs = nsing

         do i = 1,nsing
c
c rhstype is meaningless here as this formulation has no RHS matrix, but 
c we need to supply a legal type anyway.
c
            rhstype(i) = CONSTANT_SOURCE
            lhstype(i) = CONSTANT_SOURCE
            dtype(i) = 1
c
c The solution is known in closed form.  We let xcen(3,i) be cos(theta).
c
            exact_sol(i) = -(3./(8.*3.141459265))*xcen(3,i)
            rhsvect(i) =  -xcen(3,i)
            rhsindex(1,i) = i
            lhsindex(1,i) = i
         end do
c
c This is a field computation with the number of field points different
c from the number of singularities (it can be greater or less).
c
      else if (job .eq. 0) then
         fljob = 0
         nrhs = nsing
         nlhs = nsing
c
c This is the translating sphere single-layer formulation.
c
         do i = 1,nsing
            rhstype(i) = CONSTANT_SOURCE
c
c lhstype is meaningless here as this computation has no LHS matrix, but 
c we need to supply a legal type anyway.
c
            lhstype(i) = CONSTANT_SOURCE
c the solution depends on where we collocate, the input rhsvect does not:
            exact_sol(i) = -(1./2.)*xcoll(3,i)
            rhsvect(i) = -(3./(8.*3.141459265))*xcen(3,i)
            rhsindex(1,i) = i
            lhsindex(1,i) = i
         end do
c
c Here we compress the existing field point vector to half its length, 
c leaving out every other point.
c
c         nlhs = nsing / 2
c         do i = 1, nlhs
c            exact_sol(i) = exact_sol(2*i - 1)
c            do j = 1,3
c               xcoll(j,i) = xcoll(j,2*i - 1)
c            end do
c         end do
c
c Here we choose a few field points off the sphere.
c
         nlhs = 6
         do i = 1,nlhs
            cos_theta = xcen(3,i*10)
            sin_theta = sqrt(1.0 - cos_theta*cos_theta)
            cos_phi = xcen(1,i*10) / sin_theta
            sin_phi = sqrt(1.0 - cos_phi*cos_phi)
            xcoll(1,i) = 1.2 * sin_theta * cos_phi 
            xcoll(2,i) = 1.2 * sin_theta * sin_phi
            xcoll(3,i) = 1.2 * cos_theta
            exact_sol(i) =  -(1./2.)*cos_theta/(1.2*1.2)
         end do
c
c Here we extend the existing field point vector to its length plus
c half again by just duplicating points.
c
c         nlhs = nsing + nsing / 2
c         do i = nsing + 1, nlhs
c            exact_sol(i) = exact_sol(i - nsing)
c            do j = 1,3
c               xcoll(j,i) = xcoll(j,i - nsing)
c            end do
c         end do
      end if
c
c Call fastlap to compute a solution or field at the vector of field points.
c
      numitr = fastlap(nlhs,nrhs,nsing,x,shape,dtype,lhstype,rhstype,
     $     lhsindex,rhsindex,lhsvect,rhsvect,xcoll,xnrm,numlev,nummom,
     $     maxitr,tol,fljob)
      write(*,'(//i3,
     $     '' iterations knocked down residual to:'',e14.8)')
     $     numitr, tol
c
c We set up repeated calls here to test that memory is freed.
c
      if (job .eq. 4) then
         call_count = call_count + 1
         write(*,'(/''*#*#*#* FastLap call number:'',i4/)') call_count
         tol = tolpar
         do i = 1,nlhs
            lhsvect(i) = 0.0
         end do
         go to 4
      end if
c
c Asess the solution for the various options.  We measure the
c point-wise error of the solution and the exact solution and
c then normalize by the area of the panel upon which the point 
c resides.  This provides an error metric that would track the
c convergence of an integrated quantity like added mass or 
c capacitance.
c
      open(unit=99,file='driver.out',status='unknown')
      write(99,'(''    xcoll(1,i)  xcoll(2,i)  xcoll(3,i)  
     $   exact(i)    rhsvect(i)  lhsvect(i)'')')
      if (job .eq. 1) then
c
c Compute max and average errors on the Neumann and Dirichlet
c surfaces for the Green formulation.
c
         do i = 1,nlhs
            if(type(i) .eq. 0) then
c This is a panel on the dirichlet surface.  Note how we decode
c the solution due to the sign in the equation we are solving that
c fastlap has no way to know about.
               lhsvect(i) = -lhsvect(i)
               error = sqrt((exact_sol(i) - lhsvect(i))
     $              * (exact_sol(i) - lhsvect(i))) * area(i)
               max_diri = max(max_diri,error)
               ave_diri = ave_diri + error
               cnt_diri = cnt_diri + 1.
               write(99,999) xcoll(1,i),xcoll(2,i),xcoll(3,i),
     $              exact_sol(i),rhsvect(i),lhsvect(i)
               max_area = max(max_area, area(i))
            else if(type(i) .eq. 1) then
c This is a panel on the neumann surface:
               error = sqrt((exact_sol(i) - lhsvect(i))
     $              * (exact_sol(i) - lhsvect(i))) * area(i)
               max_neum = max(max_neum,error)
               ave_neum = ave_neum + error
               cnt_neum = cnt_neum + 1.
               write(99,999) xcoll(1,i),xcoll(2,i),xcoll(3,i),
     $              exact_sol(i),rhsvect(i),lhsvect(i)
               max_area = max(max_area, area(i))
            end if
         end do
         if (cnt_diri .ne. 0) then
            ave_diri = ave_diri / cnt_diri
            write(*,'(//''Average absolute error on Dirichlet''
     $           '' surface ='',f13.8)') ave_diri/max_area
            write(*,'(''Maximum absolute error on Dirichlet''
     $           '' surface ='',f13.8)') max_diri/max_area
         end if
         if (cnt_neum .ne. 0) then
            ave_neum = ave_neum / cnt_neum
            write(*,'(''Average absolute error on Neumann''
     $           '' surface ='',f13.8)') ave_neum/max_area
            write(*,'(''Maximum absolute error on Neumann''
     $           '' surface ='',f13.8)') max_neum/max_area
         end if
c
      else if ((job .eq. 2) .or. (job .eq. 3) .or. (job .eq. 4))then
c
c Evaluate the errors for the single layer formulation.
c
         do i = 1,nlhs
            error = sqrt((exact_sol(i) - lhsvect(i))
     $           * (exact_sol(i) - lhsvect(i))) * area(i)
            max_error = max(max_error,error)
            ave_error = ave_error + error
            cnt_error = cnt_error + 1.
               write(99,999) xcoll(1,i),xcoll(2,i),xcoll(3,i),
     $              exact_sol(i),rhsvect(i),lhsvect(i)
            max_area = max(max_area, area(i))
         end do
         ave_error = ave_error / cnt_error
         write(*,'(//''Average absolute error on entire surface ='',
     $        f13.8)') ave_error/max_area
         write(*,'(''Maximum absolute error on entire surface ='',
     $        f13.8)') max_error/max_area
      else if (job .eq. 0) then
c
c Evaluate the errors for the field computation.
c
         do i = 1,nlhs
            error = sqrt((exact_sol(i) - lhsvect(i))
     $           * (exact_sol(i) - lhsvect(i))) *area(i)
            max_error = max(max_error,error)
            ave_error = ave_error + error
            cnt_error = cnt_error + 1.
            write(99,999) xcoll(1,i),xcoll(2,i),xcoll(3,i),
     $           exact_sol(i),rhsvect(i),lhsvect(i)
               max_area = max(max_area, area(i))
         end do
         ave_error = ave_error / cnt_error
         write(*,'(//''Average absolute error on entire surface ='',
     $        f13.8)') ave_error/max_area
         write(*,'(''Maximum absolute error on entire surface ='',
     $        f13.8)') max_error/max_area
      end if 
 999  format(3f12.6,4x,3f12.6,4x,f12.6)
      stop
      end










